[Music]
welcome back everyone
today i'm going to introduce you to
another algorithm this time a bit more
mathematical than the lift algorithm
and i'm going to use that to illustrate
the main concepts of python programming
well this course we're going to cover a
number of the most important data
structures
today we'll look at python's version of
lists which
are a bit different from lists you'll
encounter on your other courses
there's quite a lot of detail in this
session and if you've not done a lot of
programming
you probably won't get it all the first
time so
there's a transcript of this session and
there's also a set of accompanying
slides which summarize the material
so after you've watched this video go
through those slides
and check that you understand everything
if there's still material you don't
understand
please ask a question on piazza don't
worry if you're not sure how to ask a
coherent
question even confused questions are
fine
you can ask anonymously if you want but
please use public questions instead of
private ones so others can see the
discussion
and they can learn from it too okay so
we've got
quite a bit to get through so let's get
started
[Music]
now you might think computer algorithms
are a new thing but
our argument of the week this week is
over 2 000 years old
and dates back to euclid of alexandria
now
euclid is interested in the properties
of integers and rational numbers
when you're dealing with rational
numbers it's really useful to be able to
know the the greatest common denominator
or gcd because that says you simplify
fractions
for example how about this fraction
can we simplify this well we can if we
know that the greatest common
denominator
of 390 253 and
228 769 is
13457 because
then we can rewrite 390 253 divided by
228 769 as
29 times 13 457
divided by 17 times 13 457
and we can cancel the thirty thousand
forty sevens and we end up with
29 over 17. but
how can we compute the greatest common
denominator um
you could factor the numbers but that
turns out to be hard problem for
larger numbers so is there a simple way
it turns out that there is and nuclear
found an algorithm for doing this
2 300 years ago
so what is euclid's algorithm
consider the two inches which you want
to find the greatest common denominator
take the smaller one and subtract it
from the larger one
replace the larger one with that result
and
keep the smaller one and use those two
as your two new numbers
just repeat this process until the two
numbers are equal
once they are equal the resulting number
is the greatest common denominator
now we're going to implement this
algorithm in python but
first we should convince ourselves that
this actually works
let's consider the positive integers a
and b where a is greater than b
a is equal to alpha times the greatest
common denominator of a and b
and b is equal to beta times the
greatest common denominator a and
a and b and because of the greatest
common denominators we know the greatest
commonality of alpha and beta must be
1. okay so how are we going to prove
that euclidean's algorithm always works
well to do that we're going to have to
go through the steps of the algorithm
and demonstrate that they preserve the
greatest common denominator
so at each step of the algorithm we take
the smaller number and subtract it from
the larger number
so in this case b we subtract from a to
produce
a prime and so a prime
is also from the definitions on the left
equal to alpha minus beta
times the greatest common denominator of
a and b
now to prove the algorithm works we need
to show that the greatest common
denominator of a prime and b is the same
as the greatest common argument of a and
b
if that's true if we can show that then
every step of the algorithm will
preserve that constant
and when we get to the end we will end
up with the greatest common denominator
of a and b
in the results
now the greatest common of a and b is
a factor of both a prime up here
and b over here so
we know that the greatest common areas
of a prime and b must be greater than or
equal to the greatest common omega of a
and b
but we need to show that it's equal to
not greater than or equal to
and so we've got to rule out that
possibility
so how we're going to do that well
there's a fairly simple proof by
contradiction we can apply
so we'll start by assuming that the
greatest common right of a prime and b
is greater than the greater common omega
of a and b
now if that's true then the greatest
common writer of
alpha minus beta and b is equal to
some constant c which is greater than
one
if c was equal to one then that would be
equals but if it's
we've got a constant that's greater than
1 then that implies this is a greater
than here
okay so from that we can infer
that beta is equal to that number c
times some other number r don't really
mind what that number is but some other
number r
and also that alpha minus beta is equal
to that same number c
times some other number r now we can
take these two
lines and we can add them together and
what we get
is alpha is equal to that same number c
times r prime plus r
now this gives a little bit of a problem
because
alpha and beta are now both divisible by
c
and if alpha and beta are both divisible
by c
then this cannot be true the greatest
common order of alpha and beta cannot be
one
and so we end up with a contradiction
and that contradiction
means that this assumption that we made
greatest command of a prime and b
being greater than the greatest
combination of a and b must be untrue
so that rules out that last possibility
and so we can show this way that the
greatest common art of a prime and b
is equal to the greatest common order of
a and b and
hence we've shown that every step of
euclid's algorithm preserves
the greatest common denominator and
therefore when the algorithm finally
finishes
the greatest common denominator is what
is left
and that's how we can prove that this
algorithm actually works
[Music]
okay so now we know the algorithm works
let's actually try this out in python
and see how we get on
okay so here's the terminal window let's
fire up python
now what we're going to do is we're just
going to manually run euclid's algorithm
for the numbers 42 and 30.
so a is equal to 42
and b is equal to 30.
now obviously we want to run each step
of the algorithm so at the moment the
the smaller number is
is b so we're going to
subtract b from a
so
and that's now the replacement for a so
a is equal to v and so we can see how
we've got on we can print out
a and b and now
a is 12 and b is 30.
so now we run the next step of the
algorithm we're going to
subtract b from a so b
is going to become b minus a
a and
now a is still less than b so we're
going to repeat that step again
b is equal to b minus a
and now b is the smaller value so a
is equal to a minus b
and now the two numbers have become
equal and according to euclid's
algorithm when they become equal
we have reached the greatest common
denominator and the greatest combinator
of a
and b before 2 and 30 is indeed 6.
so we've now used python to implement
euclid's algorithm
well we sort of have we've really used
python like a glorified
calculator and that's not really what we
want to do here we actually want to
automate this process
and so we need to take a few more steps
to actually use python to actually do
this properly
before we rush on though let's actually
just take a few moments to reflect on
what we've seen so far
so let's go back to this terminal window
so what have we seen here we've seen a
lot
of these kind of python commands these
are our statements in the program
and all the code lines are actually
statements
we've also seen um certain types of
statements
so for example a equals 42 here is an
assignment
it assigns the value of 42 and
associates that with the name
a and so we've
assigned various different variables
here a b and v
and so forth in the code and
assignment basically takes whatever is
on the right hand side it calculates the
value of it
in this case um there's a value here
calculated
a minus b and assigns that to the
variable v here
on the right hand side these are
expressions so an expression could be
something really simple like a constant
or it can be some piece of maths like a
minus b or something more complicated
the expression calculates a value once
it's calculated that value
it will put it in to the variable on the
assignment on the left hand side here
now one thing that might look a little
bit odd to you
is a statement like this one now in this
case
if you're a mathematician you either go
that's broken or you say that a is zero
but that's not the case in programming
what we've done here is we've calculated
the expression here
b minus a and that produced the
particular value in this case 18
and then it associated the name b
with that value now we had b on the
right hand side
when it meant 30. so what we've actually
done here is to calculate a value here
b minus a which gives the value in this
particular case of 18
and then reuse the name b for that same
value
you've got to be pretty careful when you
reuse names that it's the same basic
concept otherwise you'll confuse
yourself in a big way
now mathematicians really don't
particularly like this sort of
expression where you can reuse a
variable on one side on the other
because this is not and i repeat not
a indication of equality
equals in python is always an assignment
now when you're calculating expressions
um
the obvious thing to ask is is what is
the order of precedence of the operators
in other words
if i do something like two
plus three times four what will it do
well python pretty much does what you
expect from your from from your math
background
python will do the three times four
first and then add
the two to it so what you're getting
there is exactly the same as if you did
two types two plus three times four like
that
now of course you can force the the
operation to be in different order if
you wish by
using brackets if i could type properly
and that will do the two plus three
first and then multiply by four
and so if you're not sure what the
precedence order is you've got yourself
confused you can always put brackets in
there to force it but
in general python will do what you
expect when it comes to the precedence
order of of operations
now unlike in some other languages when
you're doing assignments
python can do simultaneous assignments
so for example
rather than writing a equals 42
and b equals 30 python can also cope
with doing
two at the same time in a way like this
and that will have exactly the same
effect it will reprint out a and b
they will done now right now this
doesn't seem something very useful but
it turns out that actually it is and
we'll come back to this a little bit
later on
[Music]
now python is what's known as a strongly
typed
and a dynamically typed language by
strongly typed i mean that every
variable
and expression has a type associated
with it all the expressions in
in the example we've just seen are of
type int
means that they represent integers
only operations that are supported by
that type
um can be performed on expressions of
that type
so if you try to form an unsupported
operation python will complain
by dynamically typed i mean that python
figures out
type things for itself while the program
runs and operations are checked
as the program runs to ensure they're
permitted
in contrast a statically typed language
would perform this sort of check
before the program executes to decide
type safety before execution
a static type language usually requires
you to annotate the code
to tell the language the type of
everything
type systems are one of the most popular
methods to ensure program correctness
they ensure that only permissible
operations are executed
and they eliminate a large number of
potentially trivial bugs
type systems aren't really a substitute
for testing or further verification of
correctness
so back to our primitive python int type
um int is primitive in the sense that
the python language itself knows about
out of the box
unlike most programming languages python
can cope with integers of arbitrary size
so you never need to worry about whether
an issue is too big to represent in the
computer
python's int type supports the usual
arithmetic operation so plus
minus star symbol for multiply star star
for raised to the power
divisions a little more complicated the
operator
is integer division for example 14
5 gives 2. it always rounds down
there's also a remainder operation which
python uses the percent symbol for
so 14 sine 5 will give
4. there is a other division operator
which is a single slash which pretty
much does what you expect
but it doesn't return an integer type
rather returns a floating point um but
we'll come back to what floating point
actually means but obviously if you
divide
three by two you don't really expect to
get one a lot of the time you expect to
get one point five and so if you do
three slash two to divide three by two
you will get 1.5 as a floating point
number
finally there's an expression or rather
a function
int of some variable x which returns the
entry representation of x
if it actually exists
out of the box python supports a number
of other types in addition to
int including complex numbers real
numbers
type for these is called float for
reasons i'm going to skip for now
truth values using the bool type strings
of characters using the stru
type and many other data structures
full list of all the supported
operations can be found in the
documentation for all the standard types
it's worth studying this at this point
higher level programming languages also
allow programmers to define their own
types
and to associate their own data with
those
permitted operations on those types this
is a
really key feature that makes
programming in such languages expressive
closer to what the intent of the
programmer
actually is freeing the programmer is
the need to always think in terms of
very low level types is one way you can
reduce the mistakes in your code
for example in the last video i defined
a lift type
and a person type in my little lift
simulator and i defined operations
they could do such as waiting for the
lift pressing the button
entering the lift and so forth and after
i'd done that
i could then think about the logic of
the algorithm in terms of those higher
level operations
[Music]
okay so back to our greatest common
denominator algorithm
now when i ran through the commands
earlier i
compared a and b myself and decided
which one to subtract from the other
and i checked each time to find out
whether the two numbers have become the
same
in other words when we've finished and
that's
really a bit too manual we really want
to automate the program doing those kind
of tests
so what we can do is we can get python
to do this for us
now commands can be made optional in
python if you use the
if else statement and the way this works
is you put an
if statement with a condition followed
by a colon
and then an else statement and
a colon and the idea is that
if the condition is actually true then
it will run
the first block of statements and if the
condition is false
it will run the second block of
statement under the else statement
and we can use this to automate the way
we decide which piece of code will be
run
so that's good that lets us decide
whether to
subtract b from a or a from b
now that's not quite enough though we
need to continue to loop around and
around and around in the program until
we've actually finished
when the two conditions are the same and
python provides us with another
control structure which lets us do this
which is a while loop
and the structure of this is you have a
while condition
statement and then a whole block of
statements that you might run while the
condition is true
and so the idea is if the condition is
is true initially it will go in and it
will keep repeating this set of
statements
until the condition becomes false and
then it will fall out at the bottom and
do whatever comes next
and so we're going to use these two
primitives the if statement
and the while loop in order to automate
our greatest common denominator program
this time i'm not going to just type
commands
at python interpreter what i'm going to
do is use an editor
to write my greatest common language as
a program and then we'll run the program
so let's get up a terminal
and we're going to edit a program called
gcd.pi
now in here we're going to do the same
things we did before we're going to
set a to 42 set b to 30.
but now we're going to actually add our
while loop while
a is not equal to b so we're going to
run around this while loop
until these two conditions become true
so what are we going to do if a is
greater than b then
we're going to subtract a subtract b
from a and replace a with that so a
equals
a minus b
else so if a is not greater than b
b equals b minus a
and then we're going to finish at the
end we're going to print out
what a is and that point a should be
same as b
okay so there's several things to bear
in mind here the first is this block of
code that's within the while loop here
is indicated by the fact that these
things are all indented if statement is
indented within the while loop
you've got to be pretty consistent with
how you do that indentation you should
generally use spaces rather than tabs to
do this and you've got to be consistent
with how many spaces you indent by
so this if statement for example is
indented by four spaces and so is this
else statement
because they're at the same level of the
program okay
so it's going to go into this while loop
this particular condition here a is not
equal to b it will keep running
around and around running this if else
block until a becomes equal to b
and within there we've got an if
statement of a is greater than b then
we'll run this statement we'll subtract
b from a
else b must be greater than a or equal
to
um then we'll go through and run this
version of the of the code
so we'll run around and round this loop
until eventually
a becomes equal to b and we'll drop out
the bottom and print out a
so that's it that's our whole program so
we'll save that
and let's just run it
and it works it comes out with six at
the end
and we expected that because we've tried
this algorithm before but that's for the
the whole piece of code
uh for running this program it's a
complete program now to calculate the
greatest common denominator
and we can use this code to calculate
greatest common numbers of any two
numbers just by setting their values of
a and b
while we're here let's just talk a
little bit about these conditions
we've got one condition there and
another condition there
so what is a condition um a condition
is basically um an expression just like
we had before with with
a minus b and things like that except
for these ones we're a condition that
will return true
or false and so this while condition
must be an expression that is of type
bool boolean
and same with this if condition it must
be an expression that returns
type bool and you can use all the
obvious comparison operators less than
greater than greater than equal to in
there um
you can also use uh boolean operations
as an and
or a not and things like that now one
thing to bear in mind
is that you've got to be very careful
with
the equals operator so we could equally
well have said instead of
if a is not equal to b we could have
done if not
a is equal to b but you've got to be
careful there to use that double equal
sign
because if you remember single equals in
python is always assignment
if you want to compare whether a is
equal to b that's two equal signs
it's a very common mistake to make but
just have to get used to it it's pretty
much that way in most programming
languages
so make sure that whenever you're
comparing
for to come up with a true or false
value your comparison is always two
equal signs
when you're assigning it's always a
single equal sign
[Music]
now another thing to bear in mind with
these conditions
is that they are what's called lazily
evaluated
now what do i mean by that probably
better if i show you with an example
so let's just
open another thing so suppose i wanted
to have a condition that was true
when x divided by
y divided by x is greater than 2
okay and it doesn't really matter what
we do
print hello so that's all very well we
can do that we can divide
y by x and compare that with two and it
produces a nice boolean expression
and an all is well except
what happens if x is zero if x is 0
then y divided by x will cause an error
and so
if you're writing code like this you
might want to protect this as it doesn't
actually cause an error and so what we
can do is
if x is not equal to 0
and y divided by x is greater than 2
then print out hello now
at this point probably what you should
be thinking is how does this prevent the
problem
if it's going to evaluate all of the
right-hand side here
then it will still try to divide y by
x and cause a problem despite the fact
we've put this condition here
and that would be true except for this
property of lazy evaluation
so what happens is it will evaluate
these boolean terms that are connected
by this and statement
in a lazy manner it will evaluate this
one
and if it turns out that
x is equal to 0
then this will be false so it knows that
the and will be false so it won't bother
to evaluate this part
and so it simply will disappear past
here and not print out hello
whereas if you to try to evaluate this
and then evaluate this and then add them
together
then your program would have still
crashed at this point and so this is a
really useful property to know about
this lazy evaluation of conditions it's
uh it's very useful to be able to avoid
this kind of error
and not have to evaluate part of it if
the first
cheap test turns out to be in this case
false
[Music]
now back to our gcd code
okay so this program works
and it's complete in in a sense
um but it's a really good idea to
actually
divide our code up into functions rather
than just put all of this code at the
top level where it runs immediately
things are started
so to do that we can define a new
function
and we're going to call it gcd and
this gcd function is going to take two
parameters a and b
and those parameters could be anything
now because we're defining a new
function
using this def to define function
statement
everything within the function needs to
be indented into a block to show this
within a function so i'll move all this
lot across like that and so now
we have a new function called gcd
and we can actually call that function
so whereas before
we had to find these variables a and b
i'm not going to use those anymore
we're going to find some new variables
ax and bx
just giving them different names so they
don't get confused with the original
ones
now the function at the moment computes
its value
and it gets to this point and once it
finishes that while loop
a finally equals b um
now what we want to do is to actually
return the the value
to the place where the function is being
called from
so we can add that return statement
there and then down here
we can do say v equals gcd
of ax ax
8x bx
and so this will call our function and
put the value into v and then we can
print out v down here
and well let's try that and run it
and again it works now it's not a very
exciting program but
this illustrates key point here that
what we're doing here is to divide our
code
up into higher level functions that we
define ourselves
so when i actually use the gcd function
and i can use it as many times in my
code as i wish to use it
then i only need to think about what the
function does
it calculates the greatest common
denominator whereas
inside the gcd function that's where you
care about
how it calculates the greatest common
denominator and
this makes we lets us think about our
code in higher level functions so i'm
only really thinking about gcd as a
function that now when i use it
down in the outside code whereas we've
hidden away
the definition of it up here
[Music]
now what's going on with all these
variable names and
why are they different names why am i
using ax and bx in one place and a and b
in the other
well we need to figure out a little bit
about what the scope of variables
means in other words where they're
actually available
when when i call gcd down here
um i'm giving it these parameters ax and
bx
now that's passing a value into this
function but when it's in the function
that particular value here that i passed
in as ax
is passed in and is stored temporarily
in this variable called
a so long as we're in the gcd function
so if i go into here and i can
print this out i can print out a
equals a
and we can actually see that when we run
this
it will print out a equals 42 and that's
exactly what we want
we want the the value being passed in
here to appear in our function
now if i try to print out
what a is out here
outside of the scope of the the gcd
function
python gives me an error basically a is
not defined out there
and it's not defined down here either
still an error the thing is that these
variables a
and b are only defined within the scope
of this function
now why is that a good thing well it's a
good thing because it means that i
don't i can use these variables in my
calculations within the gcd function
without them causing any conflicts with
any other variables anywhere else in my
million line program well this isn't
really a million line program but if i
did have a million line program
i could use these funk these variables
safely within the gcd function
without them causing any conflict with
any other variables of the same name
anywhere else in the program
that matters when your code gets big it
doesn't really matter very much for a
function as small as gcd here
now python scope rules are just a little
bit more complicated than this
so python actually has a rule for when
you're looking
trying to find a variable name or
function name something like that
where will it find it if there's more
than one of the same name so first of
all
it will try the the local scope and if
you can find the
the variable or the function name within
the local scope of the function that you
happen to be in right now
then great it will use that one if it
can't find it there then it will search
onwards and it will look in the
enclosing function now
enclosing functions aren't something
i've shown you so far but it's possible
to define one function within
another function and in that case the
variable names of the outside function
are available
to the inside function in this way it's
not a really common feature that i use
but
it's sometimes useful the the next scope
that
might come up is if you can't find it in
either of those scopes it will fall all
the way out to global scope
and in our gcd code the variables ax and
bx were defined at global scope they're
available
all the way through the whole program um
and finally
if you can't find the the name anywhere
there it will look at the
set of built-in python names the names
of
functions and things like that that are
just built into the language
and so those are the the rules it will
it will try the local scope first if it
fails to find a variable in the local
scope
you will look in the enclosing function
you can't find it there it'll look for
global and if you can't find it there
it'll look at the
the built-in names of course these rules
mean that it's possible to redefine the
built-in names if you wish to do so
though it's usually a bit confusing to
do it and i wouldn't really recommend it
unless you know what you're doing
okay so now we know how to write a
function
but when should you use a function
in the end this mostly comes down to
experience but there are a couple of
guiding principles
that may help the first of these is
called the abstraction principle
and it says each significant piece of
functionality in program
should be implemented in just one place
in the source code
and it goes on to say that where similar
functions are carried out by distinct
pieces of code
it's generally beneficial to combine
them into one
by abstracting out the variable parts
so why is this a good idea well
if you've got a piece of functionality
and you end up using cut and paste and
putting that piece of functionality into
different places in the code
and later on you come along and you
subtly change
how you're actually going to solve the
problem then you've got to make sure
that you go through and you're
consistent
everywhere in the code where you make
the change and it's really hard to do
that once code gets big
whereas if you've abstracted the
functionality out into a function
so that piece of functionality is only
in one place then
when you come to change things later and
you will come and change things data
because that's how coding works
um then there's only one place you need
to be to keep consistent you don't end
up with these different inconsistencies
going on throughout your source code
so that's the first principle the second
principle is sort of similar
which is called the don't repeat
yourself principle
and this doesn't talk much about
functions but pieces of knowledge
and it says every piece of knowledge
must have a single
unambiguous authoritative representation
within
a system and so what this means is when
you're storing data you need to make
sure that there's an authoritative
representation of the data sometimes we
have data in one form and we convert it
to another form
and now it's in two different forms and
now the problem is which one is the real
version and which one is the copy of it
and it's very easy to get yourself into
a mess doing that so
the key thing here is if you only have
one authoritative version of the data
and then if you need to transfer into a
different form you do it whenever you
need to
then you don't end up with that real
sort of doubt as to which version is the
authoritative
unambiguous version of the code uh or
rather of the data in this particular
case
um and this again helps keep your code
from from being confused and cluttered
especially as you evolve the code later
on
now one other really good reason to
write a function
is it allows us to write unit tests for
our code
so once we've got a function we can then
write a series of tests
to prove to our satisfaction that our
function actually works the way we
expect it to
and then we can actually build up our
more complicated code out of pieces that
we have some confidence in
rather than having bugs all the way
scattered through our code
so let's go back to our gcd code and
actually write a little test function
so i can actually just define a new
function
test gcd
and we'll feed it in our usual values 42
and 30.
we'll calculate the gcd of 42 and 30 and
then we'll
assert that v is is equal to
6 which is should be the correct answer
and so that's
a simple unit test for gcd it will feed
in the values 42 and 30. it will
calculate the answer and check that the
answer actually equals six
and if the answer doesn't equal six it
will cause a test failure
and we can then run that in pi test
pi and it will run our test and it says
our test
passed and that's sort of as we'd expect
because we've been testing with those
particular parameters all along
now this isn't a really good test
it only tests with those two parameters
it's definitely not a comprehensive test
so what sort of things should we be
testing for
so first of all it probably good to test
more than one pair of parameters
but we can't really possibly test all
possible parameters
so we're going to need to focus on
particular cases
brian kernighan and rob pike in the
practice of programming
provide some advice firstly they say
you should test for coverage make sure
that all lines and all
code paths are tested now in my
experience
if a conditional branch in your code has
never been tested there's at least a 50
chance that it doesn't work so i agree
completely that's really good advice
now the second thing you can do is to
compare different implementations
and check refactoring and refinement of
your code
so for example you might first of all
write a
really simple but inefficient
implementation of some algorithm
and then later on go back and rewrite it
to be much more efficient
and elegant and so forth but the more
efficient and elegant version is
probably harder to write
and more difficult to get correct so
then
the fact you've got the simple version
and the more complicated elegant version
means you can test the two against each
other and you can automate automatically
test against them for a large number of
parameters
it gives you some confidence that your
your faster more elegant version
actually does the same
task the next thing you should do is
test for
boundary conditions values and special
cases
so in the case of our gcd code
there are some obvious boundary
conditions and special cases
for example it would probably be a good
idea to test what happens when the code
starts
with a and b being the same the greatest
common denominator of
6 and 6 is 6 but
does our code handle that correctly we
should add a test and be sure that it
does
the next useful piece of advice is to
identify
and test that pre and post conditions
hold
so for our gcd code what do we have in
terms of pre or post conditions well
we can go back to our proof in our proof
we
assumed that a and b were positive
integers
that's a precondition what will our code
do
if we call it with negative parameters
there's a pretty good chance it doesn't
do the right thing and so we should
probably actually test for those
preconditions and be sure that they're
correct
in a similar vein if you can identify
conservation properties that's something
that should
always be true then you can add tests to
make sure
that something always should be true
actually is true
finally you should check error returns
and exception paths
lots of code works just fine until an
error occurs and then does something
really stupid
now as programmers we tend to fixate on
good cases because that's the problem
we're actually trying to solve
but handling the error cases correctly
is just as important
so you should add tests that check what
happens when things go wrong
now you could write a whole book on
error handling
one thing that you can be absolutely
sure of is users of your code
will find ways to use it in invalid ways
and that exceptional circumstances will
occur
now there are several general principles
that occur when it comes to
error handling so for example on
encountering an error your code
should fail fast and never fail silently
you shouldn't hide an error your code
should
handle errors and exceptions that are
the result of any external factors that
somebody might throw at you
one external factor is your own future
self using your own code
in an unexpected unexpected way
um when you handle an exception case
it mustn't obscure the intent of your
code
when it's running along on the happy
path um if your
error handling code makes the the normal
code
case difficult to understand you'll end
up making a code impossible to maintain
and then as far as possible you should
use language facilities to handle errors
and exceptions
okay so should we see if we can apply
some of those lessons to our gcd program
so the first thing we should do is we
should check for those special cases
that we talked about
so
let's add a second gcd test
we'll call it test gcd 2 and we'll test
for what happens when it starts off
where ax and bx are equal
and both equal to 6. now
if we eyeball the code we would expect
this test to pass
because when a and b start off the same
this condition is not true so it will
never execute any of the steps in the
loop
and it will simply return what we
started with so we'd expect that to work
but it's probably a good idea to
actually test it because it's very easy
to delude yourself that code works when
it actually doesn't so we'll run that
so we're on pi test gcd.pi and
indeed it says that two tests passed in
0.01 seconds okay so that's good it
works in that special case
now what else should we do well the
other thing we
look we talked about was these
preconditions what should be true before
your function starts and so what we can
do
is we can test maybe the fact that these
weren't positive integers
and so we can add
another test gcd
3 and let's set
a to be 42 and b to be
minus 30. now
what does it mean to do the greatest
common denominator of a negative number
it actually doesn't really make any
sense so
we don't really necessarily expect this
to return the right answer but
the obvious question is what will it
actually do well
let's try it and see i'll run pi test
and it's still
running and it's still running
a little bit of a suspicion here it
might have gone to an infinite loop if i
type control c
it will terminate that and you can see
it passed two tests
but it didn't complete the third
okay so what's going on well
we started off with in this test um
bx of being -30 so within the function b
is minus 30. so they don't start off
equal so it goes into the loop
and a is positive and b is negative so
it'll do the first part of this
and it will subtract b from a
but b is negative so
a will keep getting bigger and so it
will keep going
around and around this part of the loop
and every time round
a will get bigger and bigger and bigger
and bigger but it will never reach the
point where a
is actually equal to b and so this will
never terminate
it really is an infinite loop so that's
not a good thing
we really don't want our code to be
creating infinite loops now we know that
the gcd isn't actually a meaningful
function
for negative numbers but it would be a
really good idea to protect ourselves
from our future self
to actually document that a and b must
be positive
so we can put in a comment here that
says
a and b must be positive
but a comment only goes so far a comment
is a reminder but unless you actually
look at the implementation you're not
going to actually see
so it would be a really good idea for us
to actually add a test in here
so if not a
is greater than zero and b is greater
than zero
so if our precondition is that a is
greater than
and b is greater than zero so if that is
not true then we need to do something
so what are we actually going to do um
at this point
there's no saying thing that the code
can actually do at this point the only
thing it can do
is to raise an exception and let
something else handle it and so that's
what we're going to do we're going to
raise an exception here
so raise and what type of exception is
this well it's really an
arithmetic error very
genetic error
um and what we're going to do is to
feed into the arithmetic error what we
got wrong here
percent s comma percent s
must be positive
sent a
comma b
and those need to be a tuple like that
okay so what's this going to do um this
percent s percent s will fill in
in an error message that gets returned
in this error the values
of a here and b so we get a nice
meaningful
string out when we have the trigger the
error
okay so let's run that and see what
happens
and we get an arithmetic error so it
correctly
raised the exception and this is what we
got we've got an arithmetic error and it
returned this string
42 minus 30 must be positive integer
so that's a nice meaningful error
message that at least we can see what it
was we got wrong
so that's good so far we're now
not going to infinite loop we're not
trying to silently swallow
the mistake we made but we need to also
test this and so what we're going to do
is to test what would happen in the
exception handler that actually shows
this goes this is correctly being raised
as an arithmetic error
python's way of handling exceptions is
to use a try
accept finally block so what you do is
if you've got some code that you might
throw
an exception you put that code in a
block
within a try statement and so that gives
the python environment the opportunity
to catch the exception and handle it if
that
exception is raised now the next thing
you need
is after that an accept block and the
accept block
says accept the exception name as a
variable so what this does
is if in the try block an exception is
raised
and if that exception has the specific
name
that matches exception name then it will
enter that accept block and run the code
to handle the exception and within there
the exception that was raised within
your try block is available to you as
this variable name
and finally there's a finally block at
the end and the thing about the finally
block is that that is
always run it's run irrespective of
whether an exception is raised or not
so if your try block finishes without
any exceptions you will still run the
finally block
if your tri block raises an exception
and ends up in the accept block it will
still run the finally block
and the reason for this is sometimes you
need to clean up states that you've
created
no matter whether an exception is raised
or not and so this provides a way to do
that provides a way to make sure that
the
state is always cleaned up now you can
have more than one accept block for a
single try block
and you might do that if you want to
have more than one different type of
exception be raised within the block
and you want those to be handled
differently okay so
now we've got the basic idea let's see
how we might actually handle
our arithmetic exception from the gcd
code
okay so what we need to do is
to
modify this test that we wrote our test
gcd3 which has the negative value here
and we need to modify this so that it
actually
tests out whether the exception is being
thrown correctly and we can use that to
show
how we actually use try except finally
so we know that the gcd
can raise an arithmetic exception so
what we're going to do is to put that
into a try block now
what we want to in our test to be sure
of is that if we do actually feed it
a negative number it never actually gets
to this point
so what we can do is we can assert false
here
and so that will cause the test to fail
if it ever gets to this point in the
code and we know it shouldn't get to
this point in the code because what
should happen
is gcd should raise the exception okay
now we need to handle the exception
so we need to accept and what type of
error was it does it through well let's
go back up and check
it's an arithmetic error here so
we'll make sure that we
we have an exception handler for an
arithmetic error
and we want to actually be able to print
out the values so
except arithmetic error as e e is now a
variable which will
catch that arithmetic error okay
so now we want to make sure that
the error that's raised is actually the
version of the arithmetic error that we
actually want
so what we're going to do is assert
that if we scroll back up our code here
that this string must be positive int
it's actually part of our error message
so we can assert that string
here must be positive int
that's what we're looking for is
in and we can take the arithmetic error
and force that to be a string
and this will actually extract the
particular error message we send and
just check that that's there
so we can assert that if an arithmetic
error is actually raised
we should catch it here and we'll assert
that it's the right got the right error
message
in there that we were looking for okay
now that's great that tests
that the error message we expected is
being raised
we should probably also test that no
other
exception is being raised so we can put
another assert
another accept block in here and this
should never be hit
so we're going to assert that that is
false
and finally
we're going to assert that that's always
run so we can assert that that's true
okay and we don't need that test because
it should never get there
so this hopefully will let us
check that when we feed in a negative
number into our gcd function
that first of all it never gets here
we need to check that it always gets
here
and that the right type fair message is
shown that it never gets there
and that it actually finally gets
through to here and so this
is a test that will actually hopefully
make sure that our arithmetic error is
actually being
raised in the way we expect it to be
raised because as we said before
if you don't actually test your
exceptions and how they're raised and so
forth
you won't really have confidence that
they work until your code fails in some
weird
silent way later okay so let's try it
out
hopefully i typed all that correctly pi
test
gcd.pi and it runs and it says all three
tests pass and so
actually i did manage to type it all
correctly and it actually works
okay so so just to recap what's going on
here the the python raise mechanism
will interrupt the flow of your program
and it will bubble the exception up to
the outer calling blocks wherever it's
being called from
now why is that a good thing well it's
because
often the error is detected deep within
your code at a point at which you can't
do anything about it
so if someone actually
for example tries to open a file and the
file name does not exist
there's nothing at the point at which
you open the file that you can do
anything about it
but you might be able to do something
about it higher up in the program you
might be able to prompt the user for
a different file name or you might
actually know that you were trying a
whole bunch of different names in case
they existed and you just want to move
on to the next one in the list it's not
there's no one answer to that
and therefore you want to handle that
exception at
the level at which you have enough
information to do something about it
now this finally block that's there to
cope
with clean up on errors because
sometimes while you're going through the
tri-block you're instantiating a whole
bunch of state
you may be building up information from
different places and instantiating some
state
and then suddenly you discover that you
can't go any further and
the trick there is you want to be able
to clean up all of that state you want
to remove that state
before you throw the exception in order
to be able to
have a nice clean error handling back up
at the higher level
and so the key thing here is to only
handle the exceptions
at the point of which you know how to do
recovery
if you don't know how to recover at a
particular level you should raise the
exception further up and so
maybe some higher level knowledge is
available there in order to handle the
error correctly
now the other thing you'll have seen is
that
i've been changing this gcd program
continuously i've added
tests i've turned it from inline code
into a function i've added
additional pieces and this process of
continually refining and improving code
that's known as refactoring and
we do that an awful lot when we're
programming programs that are not
something that you you write once and
you never ever change again that's just
not how the
how the business works programs are
these kind of living things that evolve
programs it's dynamic activity and
programs are rewritten and retested
and rewritten and retested and we add
functionality bit by bit
and often you're re-testing certainly
multiple times an hour maybe even
multiple times a minute
now evolving the program in order to
improve its quality
that process is refactoring and
when you do refactoring you want to have
confidence
that you don't break things whenever you
refactor things
and the main way you make sure you have
that confidence when you're refactoring
when you're adding functionality or
you're changing how you do something
it's by having a good test suite if
you've got good tests before you do the
refactoring
you change something you run the test
again hopefully all the tests still pass
and it gives you confidence that in
making the change you haven't
actually broken anything gives you that
real confidence
now sometimes when you're refactoring
and changing the code
you do break things and you realize you
got it wrong
and you made a bunch of changes and
actually it turned out that was a bad
idea and we want to actually be able to
roll back
what pretty much every programmer will
discover is you you add a bunch of code
you change a bunch of things you decide
that's a bad idea and you unchange them
you edit it back and you rerun the code
and it
no longer works it doesn't work the way
it did before
this happens all the time you just
manage to change something subtly and
then you waste a whole bunch of time
trying to figure out what it was you
change that you haven't managed to
reverse
the way professional software engineers
deal with this is
through using a version control system
so you check your code into a version
control system and every time you get to
the point where you're you're happy with
it
it passes at a test you commit the code
into the version control system
and then when you start to refactor you
change something
if you want to back out you can simply
roll back to the previous version
or version before that or a version
before that that's committed into the
version control system so the most
common version control system that's
used
is a system called git and
we're going to be using git on this
course as our version control system and
that gives you
confidence that when you're making
changes
and you decide you've made a mistake you
can always go back to a previous version
so in this video i've covered really
quite a lot of material
if you've done a lot of python before
you probably won't have much problem
with this material but if you've not
done any python programming
there's probably too much for you to
take in in one go so
you might want to go back and review the
video again
you might want to read through the
transcript of the video there's also a
set of slides that are associated with
video and i encourage you to go through
and make sure you
reasonably comfortable with the material
that i've covered here
because we're going to go on and from
now on we're live you're going to assume
that you know how to program in python
at least you know the basic principles
um so the next thing we're going to do
is we're going to move on and look at
the first
major data structure that python
supports the data structure is lists
and so that'll be in the next video
[Music]
you
